<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>추세 분석</title>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <!-- ✅ 공통 스타일 -->
  <link rel="stylesheet" href="./common.css" />

  <style>
    .row { display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
    .card { min-width:260px; }
    label { display:block; font-size:13px; margin-bottom:6px; }
    select, input[type="range"], input[type="text"] { width:100%; padding:8px; box-sizing:border-box; }
    .checks { display:flex; gap:12px; flex-wrap:wrap; }

    #bar { width:100%; height:620px; }
    .row2 { display:flex; gap:16px; flex-wrap:wrap; }
    #trend, #approver { flex:1; min-width:480px; height:520px; }

    #note { color:#666; font-size:12px; margin-top:6px; }
    .topn-val { font-size:12px; color:#444; margin-top:6px; }
  </style>
</head>

<body data-page="trend">
  <div class="wrap">
    <div class="panel">
      <h2>추세 분석</h2>

      <div class="row">
        <div class="card" style="min-width:360px; flex:1;">
          <label>부서(검색 가능)</label>
          <input id="deptSearch" type="text" placeholder="부서를 검색하세요" />
          <select id="dept"></select>
        </div>

        <div class="card" style="min-width:320px;">
          <label>연도(체크박스)</label>
          <div class="checks">
            <label><input type="checkbox" class="year" value="2024" checked> 2024</label>
            <label><input type="checkbox" class="year" value="2025" checked> 2025</label>
          </div>
        </div>

        <div class="card" style="min-width:260px;">
          <label>TOP N</label>
          <input id="topn" type="range" min="5" max="50" step="1" value="20" />
          <div class="topn-val">TOP N: <span id="topnVal">20</span></div>
        </div>
      </div>

      <div style="height:12px;"></div>
      <div id="bar"></div>

      <div class="row2">
        <div id="trend"></div>
        <div id="approver"></div>
      </div>

      <div id="note"></div>
    </div>
  </div>

<script>
/* ===== 고정 색상 ===== */
const COLOR_MAP = {
  2024: "#A7C7E7",
  2025: "#F7B7D2"
};

let DATA = null;

/* ===== 공통 유틸 ===== */
function mean(arr) {
  const a = (arr || []).map(v => Number(v) || 0);
  return a.length ? a.reduce((s,v)=>s+v,0) / a.length : 0;
}

/**
 * ✅ 숫자 포맷: 100 이하 => 천단위 콤마 + 소수 2자리
 *            100 초과 => 천단위 콤마 + 정수(소수 없음)
 */
function fmtNum(v) {
  const n = Number(v);
  if (!Number.isFinite(n)) return "N/A";
  if (n > 100) return Math.round(n).toLocaleString("ko-KR");
  return n.toLocaleString("ko-KR", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

/**
 * ✅ y축 tick을 직접 생성(가장 확실)
 * - 0~최대값을 기준으로 6등분 tick 생성
 * - ticktext는 fmtNum 규칙 적용
 */
function buildYTicks(yArray) {
  const arr = (yArray || []).map(Number).filter(Number.isFinite);
  const max = arr.length ? Math.max(...arr) : 0;
  const top = Math.max(0, max);

  // tick 개수(원하면 5~8 사이로 조정)
  const nTicks = 6;

  // max가 0이면 기본 step
  const step = (top > 0) ? (top / nTicks) : 1;

  const vals = Array.from({ length: nTicks + 1 }, (_, i) => i * step);
  const text = vals.map(v => fmtNum(v));

  return { tickvals: vals, ticktext: text };
}

// category x축에서 전체 폭 가로지르는 hline
function hlineShape(y, color, nCategories) {
  return {
    type: "line",
    xref: "x",
    yref: "y",
    x0: -0.5,
    x1: Math.max(nCategories - 0.5, 0.5),
    y0: y,
    y1: y,
    line: { color: color, width: 2, dash: "dash" }
  };
}

function selectedYears() {
  return Array.from(document.querySelectorAll("input.year:checked")).map(x => Number(x.value));
}

function normalizeYears(choice, allYears) {
  const picked = (choice || []).slice().sort((a,b)=>a-b);
  const all = (allYears || []).slice().sort((a,b)=>a-b);
  if (picked.length === 0 || (picked.length === all.length && picked.every((v,i)=>v===all[i]))) {
    return { years: allYears, label: "전체" };
  }
  return { years: picked, label: picked.join(", ") };
}

/* ===== 과제별 집계 ===== */
function aggCompare(records, dept, years, topN) {
  const deptTrim = String(dept || "").trim();
  const yrSet = new Set(years.map(Number));
  const filtered = (records || []).filter(r =>
    (!deptTrim || String(r["부서명"]).trim() === deptTrim) && yrSet.has(Number(r["연도"]))
  );
  if (filtered.length === 0) return null;

  // TOP N by sum over selected years
  const sums = new Map();
  for (const r of filtered) {
    const k = String(r["task_key"]).trim();
    const c = Number(r["건수"]) || 0;
    sums.set(k, (sums.get(k) || 0) + c);
  }

  const order = Array.from(sums.entries())
    .sort((a,b)=> (b[1]-a[1]) || String(a[0]).localeCompare(String(b[0])))
    .slice(0, Number(topN))
    .map(x=>x[0]);
  const orderSet = new Set(order);

  // Full grid (task, year) fill 0
  const m = new Map(); // task||year -> count
  for (const r of filtered) {
    const task = String(r["task_key"]).trim();
    if (!orderSet.has(task)) continue;
    const y = Number(r["연도"]);
    const key = task + "||" + y;
    m.set(key, (m.get(key) || 0) + (Number(r["건수"])||0));
  }

  return { order, map: m };
}

/* ===== 성명별 생산문서 건수(trend) ===== */
function renderNameBar(dept, years, topN) {
  const deptTrim = String(dept || "").trim();
  const yrSet = new Set(years.map(Number));

  const rows = (DATA.name_records || []).filter(r =>
    (!deptTrim || String(r["부서명"]).trim() === deptTrim) && yrSet.has(Number(r["연도"]))
  );

  if (rows.length === 0) {
    Plotly.react("trend", [], {
      title: { text: `${dept} 개인별 생산문서 건수 (데이터 없음)` },
      margin: { l:40, r:20, t:60, b:80 }
    }, { responsive: true });
    return;
  }

  const m = new Map();       // name||year -> count
  const nameSum = new Map(); // name -> total

  for (const r of rows) {
    const name = String(r["성명"]).trim();
    const y = Number(r["연도"]);
    const c = Number(r["건수"]) || 0;
    m.set(name + "||" + y, (m.get(name + "||" + y) || 0) + c);
    nameSum.set(name, (nameSum.get(name) || 0) + c);
  }

  const order = Array.from(nameSum.entries())
    .sort((a,b)=> (b[1]-a[1]) || String(a[0]).localeCompare(String(b[0])))
    .slice(0, Number(topN))
    .map(x=>x[0]);

  const traces = [];
  const shapesTrend = [];

  const yearOrder = (DATA.years || []).filter(y => yrSet.has(y));

  // y축 tick용: 전체 연도 값 합쳐 max 산출
  const allValsForTicks = [];

  for (const y of yearOrder) {
    const vals = order.map(name => m.get(name + "||" + y) || 0);
    allValsForTicks.push(...vals);

    const mval = mean(vals);

    traces.push({
      type: "bar",
      name: `${y} (평균: ${fmtNum(mval)}건)`,
      x: order,
      y: vals,
      customdata: vals.map(v => fmtNum(v)),
      marker: { color: COLOR_MAP[y] || "#888" },
      hovertemplate: "%{x}<br>%{customdata}건<extra></extra>"
    });

    shapesTrend.push(hlineShape(mval, COLOR_MAP[y] || "#888", order.length));
  }

  const ticks = buildYTicks(allValsForTicks);

  Plotly.react("trend", traces, {
    title: `${dept} 개인별 생산문서 건수 (TOP ${topN})`,
    barmode: "group",
    xaxis: { title: "", tickangle: -45 },
    yaxis: {
      title: "",
      rangemode: "tozero",
      tickmode: "array",
      tickvals: ticks.tickvals,
      ticktext: ticks.ticktext
    },
    shapes: shapesTrend,
    annotations: [],
    margin: { l:40, r:40, t:60, b:160 }
  }, { responsive: true });
}

/* ===== 최종결재자별 결재시간(approver) ===== */
/* ===== 최종결재자별 결재시간(approver) ===== */
function renderApproverTime(dept, years, topN) {
  const deptTrim = String(dept || "").trim();
  const yrSet = new Set(years.map(Number));

  const rows = (DATA.approver_records || []).filter(r =>
    (!deptTrim || String(r["부서명"]).trim() === deptTrim) && yrSet.has(Number(r["연도"]))
  );

  if (rows.length === 0) {
    Plotly.react("approver", [], {
      title: { text: `${dept} 최종결재자별 결재시간(주말, 공휴일 제외) (데이터 없음)` },
      margin: { l:40, r:20, t:60, b:80 }
    }, { responsive: true });
    return;
  }

  // ✅ 정렬 기준을 "평균 결재시간(가중평균)"으로 만들기
  const sumCnt = new Map();      // approver -> total count
  const sumTime = new Map();     // approver -> sum(avg * cnt)
  const perYearAvg = new Map();  // approver||year -> avg (표시용)

  for (const r of rows) {
    const a = String(r["최종결재자"]).trim();
    const y = Number(r["연도"]);
    const cnt = Number(r["건수"]) || 0;
    const avg = Number(r["평균"]) || 0;

    perYearAvg.set(a + "||" + y, avg);

    sumCnt.set(a, (sumCnt.get(a) || 0) + cnt);
    sumTime.set(a, (sumTime.get(a) || 0) + (avg * cnt));
  }

  // ✅ 최종결재자별 선택연도 가중평균(건수 가중)
  const overallAvg = new Map(); // approver -> weighted avg
  for (const [a, cnt] of sumCnt.entries()) {
    const t = sumTime.get(a) || 0;
    overallAvg.set(a, cnt > 0 ? (t / cnt) : 0);
  }

  // ✅ 내림차순: 평균 결재시간(가중평균) 기준
  const order = Array.from(overallAvg.entries())
    .sort((a,b)=> (b[1]-a[1]) || String(a[0]).localeCompare(String(b[0])))
    .slice(0, Number(topN))
    .map(x=>x[0]);

  const traces = [];
  const shapesAppr = [];
  const yearOrder = (DATA.years || []).filter(y => yrSet.has(y));
  const allValsForTicks = [];

  for (const y of yearOrder) {
    const vals = order.map(a => perYearAvg.get(a + "||" + y) || 0);
    allValsForTicks.push(...vals);

    const mval = mean(vals);

    traces.push({
      type: "bar",
      name: `${y} (평균: ${fmtNum(mval)}일)`,
      x: order,
      y: vals,
      customdata: vals.map(v => fmtNum(v)),
      marker: { color: COLOR_MAP[y] || "#888" },
      hovertemplate: "%{x}<br>%{customdata}일<extra></extra>"
    });

    shapesAppr.push(hlineShape(mval, COLOR_MAP[y] || "#888", order.length));
  }

  const ticks = buildYTicks(allValsForTicks);

  Plotly.react("approver", traces, {
    title: `${dept} 최종결재자별 평균 결재시간(공휴일 제외) (TOP ${topN})`,
    barmode: "group",
    xaxis: { title: "", tickangle: -45 },
    yaxis: {
      title: "",
      rangemode: "tozero",
      tickmode: "array",
      tickvals: ticks.tickvals,
      ticktext: ticks.ticktext
    },
    shapes: shapesAppr,
    annotations: [],
    margin: { l:40, r:40, t:60, b:170 }
  }, { responsive: true });
}


/* ===== 전체 렌더 ===== */
function render() {
  const dept = document.getElementById("dept").value;
  const topN = Number(document.getElementById("topn").value) || 20;

  const picked = selectedYears();
  const norm = normalizeYears(picked, DATA.years);
  const years = norm.years;

  const title = `${dept} 과제 문서 건수 비교 (TOP ${topN})`;
  const note = document.getElementById("note");

  const comp = aggCompare(DATA.records, dept, years, topN);

  if (!comp) {
    Plotly.react("bar", [], {
      title: { text: title },
      barmode: "group",
      xaxis: { title: "" },
      yaxis: { title: "", rangemode: "tozero" },
      shapes: [],
      annotations: [],
      margin: { l:40, r:20, t:80, b:160 }
    }, {responsive:true});

    Plotly.react("trend", [], { title: { text: `${dept} 개인별 생산문서 건수` } }, { responsive:true });
    Plotly.react("approver", [], { title: { text: `${dept} 최종결재자별 결재시간(휴일, 공휴일 제외)` } }, { responsive:true });

    note.textContent = "선택 조건에서 과제 데이터(records)가 없습니다.";
    return;
  }

  const labelMap = DATA.task_label_map || {};
  const label = (k) => labelMap[k] ? labelMap[k] : k;
  const x = comp.order.map(label);

  const yearOrder = (DATA.years || []).filter(y => years.includes(y)).map(Number);

  const traces = [];
  const shapesBar = [];

  const allValsForTicks = [];

  for (const yNum of yearOrder) {
    const yVals = comp.order.map(task => comp.map.get(task + "||" + yNum) || 0);
    allValsForTicks.push(...yVals);

    const mval = mean(yVals);

    traces.push({
      type: "bar",
      name: `${yNum} (평균: ${fmtNum(mval)}건)`,
      x: x,
      y: yVals,
      customdata: yVals.map(v => fmtNum(v)),
      marker: { color: COLOR_MAP[yNum] || "#888" },
      hovertemplate: "%{x}<br>%{customdata}건<extra></extra>"
    });

    shapesBar.push(hlineShape(mval, COLOR_MAP[yNum] || "#888", x.length));
  }

  const ticks = buildYTicks(allValsForTicks);

  Plotly.react("bar", traces, {
    title: { text: title },
    barmode: "group",
    xaxis: { title: "", tickangle: 45 },
    yaxis: {
      title: "",
      rangemode: "tozero",
      tickmode: "array",
      tickvals: ticks.tickvals,
      ticktext: ticks.ticktext
    },
    shapes: shapesBar,
    annotations: [],
    margin: { l:40, r:40, t:80, b:160 }
  }, {responsive:true});

  renderNameBar(dept, years, topN);
  renderApproverTime(dept, years, topN);

  const missing = [];
  if (!("name_records" in DATA)) missing.push("name_records");
  if (!("approver_records" in DATA)) missing.push("approver_records");

  note.textContent = missing.length
    ? `주의: data.json에 ${missing.join(", ")} 가 없습니다. (집계 포함 후 재생성 필요)`
    : "";
}

/* ===== 부서 옵션 ===== */
function updateDeptOptions(searchText) {
  const sel = document.getElementById("dept");
  const current = sel.value;
  const q = String(searchText||"").toLowerCase().trim();

  const depts = (DATA.depts || []).filter(d => d.toLowerCase().includes(q));

  sel.innerHTML = "";

  // ✅ 전체 옵션
  const allOpt = document.createElement("option");
  allOpt.value = "";
  allOpt.textContent = "(전체)";
  sel.appendChild(allOpt);

  for (const d of depts) {
    const opt = document.createElement("option");
    opt.value = d;
    opt.textContent = d;
    sel.appendChild(opt);
  }

  // 기본값 전체
  if (current && depts.includes(current)) sel.value = current;
  else sel.value = "";
}


/* ===== 초기화 ===== */
async function init() {
  const res = await fetch("./data.json", { cache:"no-store" });
  const payload = await res.json();

  const deptSet = new Set();
  for (const r of (payload.records || [])) deptSet.add(String(r["부서명"]).trim());
  for (const r of (payload.name_records || [])) deptSet.add(String(r["부서명"]).trim());
  for (const r of (payload.approver_records || [])) deptSet.add(String(r["부서명"]).trim());

  payload.depts = Array.from(deptSet).sort((a,b)=>a.localeCompare(b));
  DATA = payload;

  updateDeptOptions("");

  const deptSearchEl = document.getElementById("deptSearch");

  deptSearchEl.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();
    updateDeptOptions(deptSearchEl.value);
    render();
  });

  deptSearchEl.addEventListener("keydown", (e) => {
    if (e.key !== "Escape") return;
    deptSearchEl.value = "";
  });

  document.getElementById("dept").addEventListener("change", render);

  document.getElementById("topn").addEventListener("input", (e) => {
    document.getElementById("topnVal").textContent = e.target.value;
    render();
  });

  for (const el of document.querySelectorAll("input.year")) {
    el.addEventListener("change", render);
  }

  render();
}

init().catch(err => {
  console.error(err);
  document.getElementById("note").textContent =
    "data.json 로드 실패: 같은 폴더에 data.json이 있는지, 로컬 서버로 열었는지 확인하세요.";
});
</script>

  <script src="./nav.js"></script>
</body>
</html>

